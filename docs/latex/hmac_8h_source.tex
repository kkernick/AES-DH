\doxysection{hmac.\+h}
\hypertarget{hmac_8h_source}{}\label{hmac_8h_source}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{preprocessor}{\#pragma\ once}}
\DoxyCodeLine{00002\ }
\DoxyCodeLine{00003\ \textcolor{preprocessor}{\#include\ <stdexcept>}\ \ \ \ \ \ \textcolor{comment}{//\ For\ exceptions}}
\DoxyCodeLine{00004\ \textcolor{preprocessor}{\#include\ <string>}\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ For\ std::string.}}
\DoxyCodeLine{00005\ }
\DoxyCodeLine{00006\ \textcolor{preprocessor}{\#include\ <openssl/hmac.h>}\ \textcolor{comment}{//\ For\ the\ HMAC\ function}}
\DoxyCodeLine{00007\ \textcolor{preprocessor}{\#include\ <openssl/evp.h>}\ \ \textcolor{comment}{//\ For\ EVP\_sha256()}}
\DoxyCodeLine{00008\ }
\DoxyCodeLine{00014\ \textcolor{keyword}{namespace\ \ }\mbox{\hyperlink{namespacehmac}{hmac}}\ \{}
\DoxyCodeLine{00015\ \ \ \textcolor{comment}{//\ Create\ our\ buffer\ for\ OpenSSL\ to\ dump\ the\ value\ to.}}
\DoxyCodeLine{00016\ \ \ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ md\_value[EVP\_MAX\_MD\_SIZE];}
\DoxyCodeLine{00017\ \ \ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{int}\ md\_len\ =\ 0;}
\DoxyCodeLine{00018\ }
\DoxyCodeLine{00030\ \ \ std::string\ \mbox{\hyperlink{namespacehmac_a3c1fde6727e278b329d1dd3bb4ebd4f2}{generate}}(\textcolor{keyword}{const}\ std::string\&\ message,\ \textcolor{keyword}{const}\ std::array<uint64\_t,\ 4>\&\ key,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\&\ rounds)\ \{}
\DoxyCodeLine{00031\ }
\DoxyCodeLine{00032\ \ \ \ \ \textcolor{comment}{//\ Get\ the\ size\ of\ the\ key\ we\ use\ based\ on\ the\ rounds.}}
\DoxyCodeLine{00033\ \ \ \ \ \textcolor{keywordtype}{int}\ key\_size\ =\ \textcolor{keyword}{sizeof}(uint64\_t);}
\DoxyCodeLine{00034\ \ \ \ \ \textcolor{keywordtype}{int}\ keys\ =\ 0;}
\DoxyCodeLine{00035\ \ \ \ \ \textcolor{keywordflow}{switch}\ (rounds)\ \{}
\DoxyCodeLine{00036\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 10:\ keys\ =\ 2;\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00037\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 12:\ keys\ =\ 3;\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00038\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ 14:\ keys\ =\ 4;\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00039\ \ \ \ \ \ \ \textcolor{keywordflow}{default}:\ \textcolor{keywordflow}{throw}\ std::runtime\_error(\textcolor{stringliteral}{"{}Invalid\ round\ count!"{}});}
\DoxyCodeLine{00040\ \ \ \ \ \}}
\DoxyCodeLine{00041\ }
\DoxyCodeLine{00042\ \ \ \ \ \textcolor{comment}{//\ Translate\ our\ 64\ bit\ keys\ into\ a\ character\ array.}}
\DoxyCodeLine{00043\ \ \ \ \ std::string\ key\_bytes;}
\DoxyCodeLine{00044\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ x\ =\ 0;\ x\ <\ keys;\ ++x)\ \{}
\DoxyCodeLine{00045\ \ \ \ \ \ \ \textcolor{keyword}{auto}\ num\ =\ key[x];}
\DoxyCodeLine{00046\ }
\DoxyCodeLine{00047\ \ \ \ \ \ \ \textcolor{comment}{//\ Mask\ the\ byte,\ then\ shift\ to\ the\ next.}}
\DoxyCodeLine{00048\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ y\ =\ 0;\ y\ <\ key\_size;\ ++y,\ num\ >>=\ 1)\ \{}
\DoxyCodeLine{00049\ \ \ \ \ \ \ \ \ key\_bytes\ +=\ char(num\ \&\ 0xf);}
\DoxyCodeLine{00050\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00051\ \ \ \ \ \}}
\DoxyCodeLine{00052\ }
\DoxyCodeLine{00053\ \ \ \ \ \textcolor{comment}{//\ Generate\ the\ HMAC.\ Since\ this\ is\ more\ auxiliary\ to\ the\ main\ program,\ I\ won't\ dwell\ too\ long\ explaining\ this,}}
\DoxyCodeLine{00054\ \ \ \ \ \textcolor{comment}{//\ but\ in\ essence\ OpenSSL\ deals\ with\ character\ arrays,\ specifically\ unsigned\ character\ arrays.\ For\ convenience,}}
\DoxyCodeLine{00055\ \ \ \ \ \textcolor{comment}{//\ We\ deal\ with\ std::strings,\ which\ are\ signed\ characters.\ Therefore,\ we\ need\ to\ do\ some\ reinterpret\ casting}}
\DoxyCodeLine{00056\ \ \ \ \ \textcolor{comment}{//\ To\ convert\ these\ signed\ values\ to\ unsigned\ values.}}
\DoxyCodeLine{00057\ \ \ \ \ \textcolor{keywordflow}{if}\ (HMAC(EVP\_sha256(),\ \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const\ }\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}*\textcolor{keyword}{>}(key\_bytes.c\_str()),\ key\_bytes.length(),\ \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const\ }\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}*\textcolor{keyword}{>}(message.c\_str()),\ message.length(),\ \&md\_value[0],\ \&md\_len)\ ==\ NULL)}
\DoxyCodeLine{00058\ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ std::runtime\_error(\textcolor{stringliteral}{"{}Failed\ to\ generate\ HMAC!"{}});}
\DoxyCodeLine{00059\ }
\DoxyCodeLine{00060\ \ \ \ \ \textcolor{comment}{//\ Same\ as\ above.\ We\ need\ to\ reinterpret\ the\ output\ values\ as\ "{}signed"{}\ characters}}
\DoxyCodeLine{00061\ \ \ \ \ \textcolor{keywordflow}{return}\ std::string(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const\ }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&md\_value[0]),\ md\_len);}
\DoxyCodeLine{00062\ \ \ \}}
\DoxyCodeLine{00063\ \}}

\end{DoxyCode}

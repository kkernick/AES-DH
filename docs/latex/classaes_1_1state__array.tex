\doxysection{aes\+::state\+\_\+array Class Reference}
\hypertarget{classaes_1_1state__array}{}\label{classaes_1_1state__array}\index{aes::state\_array@{aes::state\_array}}


The state array is a 4x4 byte matrix to which AES operations are performed; also called a block.  




{\ttfamily \#include $<$aes.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classaes_1_1state__array_a6acecad29d8a66119e3cd1119d14540d}{state\+\_\+array}} (const std\+::string \&in, size\+\_\+t \&x)
\begin{DoxyCompactList}\small\item\em Initialize a \doxylink{classaes_1_1state__array}{state\+\_\+array} from a string. \end{DoxyCompactList}\item 
\Hypertarget{classaes_1_1state__array_a88471f320776c867ab15323d32bf8fb5}\label{classaes_1_1state__array_a88471f320776c867ab15323d32bf8fb5} 
{\bfseries state\+\_\+array} (const std\+::string \&in)
\item 
\Hypertarget{classaes_1_1state__array_ad540b3c26e761fe6f876879e636a5e28}\label{classaes_1_1state__array_ad540b3c26e761fe6f876879e636a5e28} 
{\bfseries state\+\_\+array} (const \mbox{\hyperlink{classaes_1_1state__array}{state\+\_\+array}} \&arr)
\item 
\Hypertarget{classaes_1_1state__array_ad437a3c5589f903976832d43a215e11b}\label{classaes_1_1state__array_ad437a3c5589f903976832d43a215e11b} 
auto \& {\bfseries get} ()
\item 
\Hypertarget{classaes_1_1state__array_a5d273a6aecc94f3674a6381d82f6dea7}\label{classaes_1_1state__array_a5d273a6aecc94f3674a6381d82f6dea7} 
const auto \& {\bfseries get} () const
\item 
\Hypertarget{classaes_1_1state__array_ae6ef63a3a8ea0ec104e5ab0e02768e77}\label{classaes_1_1state__array_ae6ef63a3a8ea0ec104e5ab0e02768e77} 
void {\bfseries xor\+\_\+arr} (const \mbox{\hyperlink{classaes_1_1state__array}{state\+\_\+array}} \&arr)
\item 
\Hypertarget{classaes_1_1state__array_a2df1584a9e2fdc4ee42e1f371d88dd47}\label{classaes_1_1state__array_a2df1584a9e2fdc4ee42e1f371d88dd47} 
void {\bfseries shift\+\_\+r} (const size\+\_\+t \&bits)
\item 
std\+::string \mbox{\hyperlink{classaes_1_1state__array_a97f2a53d028757b6972fe7a3f81b994a}{unravel}} () const
\begin{DoxyCompactList}\small\item\em Unravel the \doxylink{classaes_1_1state__array}{state\+\_\+array} back into a string. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classaes_1_1state__array_a51c20f9dba0cab4510a7239f258aad64}{Add\+Round\+Key}} (const uint64\+\_\+t \&round, const std\+::vector$<$ uint32\+\_\+t $>$ \&keys)
\begin{DoxyCompactList}\small\item\em Add the round key. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classaes_1_1state__array_abfc3fa037c3ee4e569c5d854e98ee9ac}{Sub\+Bytes}} ()
\begin{DoxyCompactList}\small\item\em A invertible, non-\/linear transformation of the state. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classaes_1_1state__array_a9dce6a9071b95fdaeebcf70cc83bbea7}{Inv\+Sub\+Bytes}} ()
\begin{DoxyCompactList}\small\item\em \+: Invert the Sub\+Bytes step of AES. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classaes_1_1state__array_a39211c4d666322d295f8bd6209bd6009}{Shift\+Rows}} ()
\begin{DoxyCompactList}\small\item\em Cyclically shift the bytes in each row. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classaes_1_1state__array_a4bf6ccb13e56b4c0e9f8a2016b20291a}{Inv\+Shift\+Rows}} ()
\begin{DoxyCompactList}\small\item\em Invert the cyclical shift in \doxylink{classaes_1_1state__array_a39211c4d666322d295f8bd6209bd6009}{Shift\+Rows()} \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classaes_1_1state__array_a783fd3589d4f0bb1cb0b17c0bef9d8e0}{Mix\+Columns}} ()
\begin{DoxyCompactList}\small\item\em Transform each column by a single, fixed matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classaes_1_1state__array_a8636f62214b4c51d33311980022a95be}{Inv\+Mix\+Columns}} ()
\begin{DoxyCompactList}\small\item\em Inverts the column transformation. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The state array is a 4x4 byte matrix to which AES operations are performed; also called a block. 

For every 16 bytes of input, the \doxylink{classaes_1_1state__array}{state\+\_\+array} organizes these bytes column first, Such that \doxylink{classaes_1_1state__array}{state\+\_\+array}\mbox{[}0\mbox{]} = \mbox{[}0,1,2,3\mbox{]}, \doxylink{classaes_1_1state__array}{state\+\_\+array}\mbox{[}1\mbox{]} = \mbox{[}4,5,6,7\mbox{]} \begin{DoxyRemark}{Remarks}
See Figure 1 of the Reference. 
\end{DoxyRemark}


\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classaes_1_1state__array_a6acecad29d8a66119e3cd1119d14540d}\index{aes::state\_array@{aes::state\_array}!state\_array@{state\_array}}
\index{state\_array@{state\_array}!aes::state\_array@{aes::state\_array}}
\doxysubsubsection{\texorpdfstring{state\_array()}{state\_array()}}
{\footnotesize\ttfamily \label{classaes_1_1state__array_a6acecad29d8a66119e3cd1119d14540d} 
aes\+::state\+\_\+array\+::state\+\_\+array (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{in}{, }\item[{size\+\_\+t \&}]{x}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Initialize a \doxylink{classaes_1_1state__array}{state\+\_\+array} from a string. 


\begin{DoxyParams}{Parameters}
{\em in} & The input string. \\
\hline
{\em x} & A mutable index of the string, so that multiple arrays can be initialized from the state class. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\Hypertarget{classaes_1_1state__array_a51c20f9dba0cab4510a7239f258aad64}\index{aes::state\_array@{aes::state\_array}!AddRoundKey@{AddRoundKey}}
\index{AddRoundKey@{AddRoundKey}!aes::state\_array@{aes::state\_array}}
\doxysubsubsection{\texorpdfstring{AddRoundKey()}{AddRoundKey()}}
{\footnotesize\ttfamily \label{classaes_1_1state__array_a51c20f9dba0cab4510a7239f258aad64} 
void aes\+::state\+\_\+array\+::\+Add\+Round\+Key (\begin{DoxyParamCaption}\item[{const uint64\+\_\+t \&}]{round}{, }\item[{const std\+::vector$<$ uint32\+\_\+t $>$ \&}]{keys}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Add the round key. 


\begin{DoxyParams}{Parameters}
{\em round} & The current round. \\
\hline
{\em keys} & The vector of keys. \\
\hline
\end{DoxyParams}
\begin{DoxyRemark}{Remarks}
Each round has 4 keys, one for each column. 
\end{DoxyRemark}
\Hypertarget{classaes_1_1state__array_a8636f62214b4c51d33311980022a95be}\index{aes::state\_array@{aes::state\_array}!InvMixColumns@{InvMixColumns}}
\index{InvMixColumns@{InvMixColumns}!aes::state\_array@{aes::state\_array}}
\doxysubsubsection{\texorpdfstring{InvMixColumns()}{InvMixColumns()}}
{\footnotesize\ttfamily \label{classaes_1_1state__array_a8636f62214b4c51d33311980022a95be} 
void aes\+::state\+\_\+array\+::\+Inv\+Mix\+Columns (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inverts the column transformation. 

\begin{DoxyRemark}{Remarks}
See 5.\+3.\+3 of the Reference. 
\end{DoxyRemark}
\Hypertarget{classaes_1_1state__array_a4bf6ccb13e56b4c0e9f8a2016b20291a}\index{aes::state\_array@{aes::state\_array}!InvShiftRows@{InvShiftRows}}
\index{InvShiftRows@{InvShiftRows}!aes::state\_array@{aes::state\_array}}
\doxysubsubsection{\texorpdfstring{InvShiftRows()}{InvShiftRows()}}
{\footnotesize\ttfamily \label{classaes_1_1state__array_a4bf6ccb13e56b4c0e9f8a2016b20291a} 
void aes\+::state\+\_\+array\+::\+Inv\+Shift\+Rows (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Invert the cyclical shift in \doxylink{classaes_1_1state__array_a39211c4d666322d295f8bd6209bd6009}{Shift\+Rows()} 

\begin{DoxyRemark}{Remarks}
This step in AES transposes values in (r,c) to (r, c-\/r \% 4) 

See 5.\+3.\+1 of the Reference. 

Inv\+Shift\+Rows is pretty much identical to \doxylink{classaes_1_1state__array_a39211c4d666322d295f8bd6209bd6009}{Shift\+Rows()}, and the inversion is simply changing c+r to c-\/r. 
\end{DoxyRemark}
\Hypertarget{classaes_1_1state__array_a9dce6a9071b95fdaeebcf70cc83bbea7}\index{aes::state\_array@{aes::state\_array}!InvSubBytes@{InvSubBytes}}
\index{InvSubBytes@{InvSubBytes}!aes::state\_array@{aes::state\_array}}
\doxysubsubsection{\texorpdfstring{InvSubBytes()}{InvSubBytes()}}
{\footnotesize\ttfamily \label{classaes_1_1state__array_a9dce6a9071b95fdaeebcf70cc83bbea7} 
void aes\+::state\+\_\+array\+::\+Inv\+Sub\+Bytes (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\+: Invert the Sub\+Bytes step of AES. 

\begin{DoxyRemark}{Remarks}
As a testament to the ubiquity and performance of using a lookup table over manual calculation\+: The Reference does not provide formulas for this stage, and I couldn\textquotesingle{}t find any implementation that doesn\textquotesingle{}t just use Inv\+SBox. 
\end{DoxyRemark}
\Hypertarget{classaes_1_1state__array_a783fd3589d4f0bb1cb0b17c0bef9d8e0}\index{aes::state\_array@{aes::state\_array}!MixColumns@{MixColumns}}
\index{MixColumns@{MixColumns}!aes::state\_array@{aes::state\_array}}
\doxysubsubsection{\texorpdfstring{MixColumns()}{MixColumns()}}
{\footnotesize\ttfamily \label{classaes_1_1state__array_a783fd3589d4f0bb1cb0b17c0bef9d8e0} 
void aes\+::state\+\_\+array\+::\+Mix\+Columns (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Transform each column by a single, fixed matrix. 

\begin{DoxyRemark}{Remarks}
See 5.\+1.\+3 of the Reference. 

Each byte in the column are combined, which provides diffusion. 
\end{DoxyRemark}
\Hypertarget{classaes_1_1state__array_a39211c4d666322d295f8bd6209bd6009}\index{aes::state\_array@{aes::state\_array}!ShiftRows@{ShiftRows}}
\index{ShiftRows@{ShiftRows}!aes::state\_array@{aes::state\_array}}
\doxysubsubsection{\texorpdfstring{ShiftRows()}{ShiftRows()}}
{\footnotesize\ttfamily \label{classaes_1_1state__array_a39211c4d666322d295f8bd6209bd6009} 
void aes\+::state\+\_\+array\+::\+Shift\+Rows (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Cyclically shift the bytes in each row. 

\begin{DoxyRemark}{Remarks}
This step in AES transposes values in (r,c) to (r, c+r \% 4) 

See 5.\+1.\+2 of the Reference. 

This step acts as the transposition stage, and is important to avoid columns being encrypted independently; if this stage was absent, AES would effectively be four separate ciphers acting on each row independently. 
\end{DoxyRemark}
\Hypertarget{classaes_1_1state__array_abfc3fa037c3ee4e569c5d854e98ee9ac}\index{aes::state\_array@{aes::state\_array}!SubBytes@{SubBytes}}
\index{SubBytes@{SubBytes}!aes::state\_array@{aes::state\_array}}
\doxysubsubsection{\texorpdfstring{SubBytes()}{SubBytes()}}
{\footnotesize\ttfamily \label{classaes_1_1state__array_abfc3fa037c3ee4e569c5d854e98ee9ac} 
void aes\+::state\+\_\+array\+::\+Sub\+Bytes (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



A invertible, non-\/linear transformation of the state. 

\begin{DoxyRemark}{Remarks}
This function takes the multiplicative inverse of each byte in the state (Or 0 if byte is 0), and then performs an affine transformation against a constant value 99. 

This function is entirely deterministic, and as such we could (and should) use a lookup table to determine values. Table 4 of the Reference provides said table, which we can use for O(1) efficiency. To better understand the process, here we manually calculate each byte, at the expense of speed. 

This step of AES provides non-\/linearity, and ensures that The resultant byte is not the same as the input. 
\end{DoxyRemark}
\Hypertarget{classaes_1_1state__array_a97f2a53d028757b6972fe7a3f81b994a}\index{aes::state\_array@{aes::state\_array}!unravel@{unravel}}
\index{unravel@{unravel}!aes::state\_array@{aes::state\_array}}
\doxysubsubsection{\texorpdfstring{unravel()}{unravel()}}
{\footnotesize\ttfamily \label{classaes_1_1state__array_a97f2a53d028757b6972fe7a3f81b994a} 
std\+::string aes\+::state\+\_\+array\+::unravel (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Unravel the \doxylink{classaes_1_1state__array}{state\+\_\+array} back into a string. 

\begin{DoxyReturn}{Returns}
The string. 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
aes.\+h\end{DoxyCompactItemize}
